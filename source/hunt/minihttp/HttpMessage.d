module hunt.minihttp.HttpMessage;

import hunt.minihttp.Define;

import std.conv : to;

/**
    * The basic class to represent both HTTP requests and responses.
    * 
    * Contains a method for grabbing the message as a string formatted for
    * sending through a server or other means.
    * 
    * Allows for setting a message body that is represented by a vector of
    * 8-bit unsigned integers. This is to allow binary data to be sent through
    * the message. But, you also can use the included methods to send plain strings.
    * 
    * This class returns as many methods as possible with a reference to the current
    * object, to try and allow for chaining methods.
    * 
    * Note: for convenience, the header for Content-Length is automatically included
    * as it is grabbed from the `_body` member. Though, it is only included if the
    * body member isn't empty.
    */
class HttpMessage
{
public:
    /**
        * Set a header in the map to the value provided.
        */
    HttpMessage SetHeader(string name, string value)
    {
        _headers[name] = value;

        return this;
    }

    /**
        * Set a number of headers based on a generic map of keys and values.
        */
    HttpMessage SetHeaders(string[string] headers)
    {
        foreach (key, header ; headers)
            _headers[key] = header;
    
        return this;
    }

    /**
        * Get the string value of a single header from the message.
        * 
        * Will return an empty string if the header does not exist.
        */
    string GetHeader(string name)
    {
        return _headers.get(name, null);
    }

    /**
        * Set the associated message method for this message.
        * 
        * Use `NONE` to switch this into a response.
        */
    HttpMessage SetMethod(HttpMethod method)
    {
        this._method = method;

        return this;
    }

    /**
        * Grab the current method for this message.
        * 
        * Returns `NONE` if this is a response.
        */
    HttpMethod GetMethod()
    {
        return _method;
    }

    /**
        * Set the path of this message, which will be used if it is a request.
        */
    HttpMessage SetPath(string path)
    {
        this._path = path;

        return this;
    }

    /**
        * Grab the current associated path of this message.
        */
    string GetPath()
    {
        return _path;
    }

    /**
        * Set the version of this HTTP message to the string specified.
        */
    HttpMessage SetVersion(string httpVersion)
    {
        this._version = httpVersion;

        return this;
    }

    /**
        * Get the current HTTP version for this message.
        */
    string GetVersion()
    {
        return _version;
    }

    /**
        * Set the status code of this HTTP message.
        */
    HttpMessage SetStatusCode(ushort code)
    {
        this._statusCode = code;
        
        return this;
    }

    /**
        * Get the status code for this message.
        */
    ushort GetStatusCode()
    {
        return _statusCode;
    }

    /**
        * Set the status message of this HTTP message.
        */
    HttpMessage SetStatusMessage(string message)
    {
        this._statusMessage = message;

        return this;
    }

    /**
        * Get the current status message for this message.
        * 
        * Returns an autogenerated status if one isn't specified.
        */
    string GetStatusMessage()
    {
        if (_statusMessage.length == 0)
            return StatusTextFromStatusCode(_statusCode);
        else
            return _statusMessage;
    }

    /**
        * Takes the headers added to the message along with
        * the body and outputs it to a `string` for use
        * in client/server HTTP messages.
        */
    string ToString()
    {
        string output = "";

        // begin by forming the start line of the message
        if (_method == HttpMethod.NONE)
        {
            output ~= HTTP_VERSION_11 ~ " " ~ _statusCode.to!string() ~ " ";
            
            if (_statusMessage.length == 0)
                output ~= StatusTextFromStatusCode(_statusCode);
            else
                output ~= _statusMessage;
        }
        else
        {
            output ~= httpMethodToString(_method) ~ " ";
            output ~= _path ~= " ";
            output ~= HTTP_VERSION_11;
        }

        // output the status lines line break to move on
        output ~= CARRIAGE_RETURN;

        // output headers to the message string
        foreach (key, header ; _headers)
            output ~= key ~ ": " ~ header ~ CARRIAGE_RETURN;

        // automatically output the content length based on
        // the size of the body member if body isn't empty
        if (_body.length != 0)
            output ~= "Content-Length: " ~ (_body.length).to!string ~ CARRIAGE_RETURN;

        // seperate headers and body with an extra carriage return
        output ~= CARRIAGE_RETURN;

        output ~= _body;

        return output;
    }

    /**
        * Set the body of this message to a string value.
        */
    HttpMessage SetMessageBody(string body)
    {
        return SetMessageBody(cast(ubyte[])body.dup);
    }

    /**
        * Set the body of this message to an unsigned 8-bit binary value.
        */
    HttpMessage SetMessageBody(ubyte[] body)
    {
        this._body = body;

        return this;
    }

    /**
        * Get the body vector for this message.
        */
    ubyte[] GetMessageBody()
    {
        return _body;
    }

    /**
        * Return the size of the binary body vector.
        */
    size_t ContentLength()
    {
        return _body.length;
    }

    /**
        * Return the amount of headers in the message.
        */
    size_t HeaderCount()
    {
        return _headers.length;
    }

private:
    /**
        * The HTTP method for this message.
        * 
        * Defaults to `NONE` denoting a response.
        */
    HttpMethod _method = HttpMethod.NONE;

    /**
        * A status code for this message.
        * 
        * This is ignored if this is a request, as requests have no notion of statuses.
        */
    short _statusCode = 0;

    /**
        * A status message to be associated with the status code for this message.
        * 
        * Keep blank to use an automatically generated status message.
        */
    string _statusMessage = "";

    /**
        * The path for the resource specified in the message. Only used for a request.
        * 
        * Defaults to blank.
        */
    string _path = "";

    /**
        * The version used for this HTTP message as a string.
        * 
        * Defaults to "HTTP/1.1"
        */
    string _version = HTTP_VERSION_11;

    /**
        * An `unordered_map` of headers using a `string` for both the key and the
        * value.
        */
    string[string] _headers;

    /**
        * A vector of unsigned 8-bit integers used to store message bodies.
        */
    ubyte[] _body;
}
